[[chapter4]]
[[Smmpt]]
== `Smmpt`: Hart MPT Extension

[[Smmpt-rwx]]
=== Smmpt

The Supervisor Physical Address (SPA) for RV32 and RV64 is shown below.
The MPT maps the SPA to read-write-execute access permissions.

[caption="Figure {counter:image}: ", reftext="Figure {image}"]
[title="RV32 Supervisor Physical Address", id=rv32-spa]
[wavedrom, ,svg]
....
{reg: [
  {bits:  12, name: 'page offset', attr: '12'},
  {bits:  3,  name: 'pn[0]',       attr: '3' },
  {bits:  10, name: 'pn[1]',       attr: '10' },
  {bits:  9,  name: 'pn[2]',       attr: '9'},
], config:{lanes: 1, hspace:1024}}
....

[caption="Figure {counter:image}: ", reftext="Figure {image}"]
[title="RV64 Supervisor Physical Address. Factors M, N, O are based on non-leaf NAPOT encodings. See <<Smmpt-napot>>", id=rv64-spa]
[wavedrom, ,svg]
....
{reg: [
  {bits:  12, name: 'page offset', attr: '12'},
  {bits:  4,  name: 'pn[0]',       attr: '4' },
  {bits:  9,  name: 'pn[1]',       attr: '9' },
  {bits:  9,  name: 'pn[2]',       attr: '9+O'},
  {bits:  9,  name: 'pn[3]',       attr: '9+N'},
  {bits:  9,  name: 'pn[4]',       attr: '9+M'},
  {bits:  12, name: 'pn[5]',       attr: '12'},
], config:{lanes: 1, hspace:1024}}
....

MPT is a `MMPT.PPN` -rooted memory structure that is used to lookup a
supervisor physical address at a page granularity to the read, write and
execute (RWX) access permissions for accesses from a supervisor domain. Each
physical-addressable page is associated with RWX access-permissions. The
supervisor physical address (SPA) components shown in <<rv32-spa>> and
<<rv64-spa>> are used to index into the `MPT` structure in memory to lookup
access permissions for the supervisor domain specified via the
MPT structures. Intermediate/non-leaf entries are used to allow this structure
to be sparsely populated. There is a format specified for XLEN=64 and
XLEN=32.

The following `MPT` Entry (`MPTE`) is specified for XLEN=64:

[caption="Figure {counter:image}: ", reftext="Figure {image}"]
[title="`MPT` entry (XLEN=64 only)", id="rv64-mpte"]
[wavedrom, ,svg]
....
{reg: [
  {bits:  52, name: 'PPN -OR- 16x3b (4b rsv:48b) PERMS'},
  {bits:   1, name: 'VALID'},
  {bits:   2, name: 'TYPE'},
  {bits:   9, name: 'RESERVED'},
], config:{lanes: 1, hspace:1024}}
....

The following `MPT` Entry (`MPTE_32`) is specified for XLEN=32:

[caption="Figure {counter:image}: ", reftext="Figure {image}"]
[title="`MPT` entry (XLEN=32)", id="rv32-mpte"]
[wavedrom, ,svg]
....
{reg: [
  {bits:  24, name: '2b:22b PPN -OR- 8x3b (24b) PERMS'},
  {bits:  1,  name: 'VALID'},
  {bits:  2,  name: 'TYPE'},
  {bits:  5,  name: 'RESERVED'},
], config:{lanes: 1, hspace:1024}}
....

The `VALID` bit determines the validity of the `MPTE`. If this bit is
set, the `MPTE` is valid and depending on the `MPTE.TYPE` field, the `MPTE` is
a valid non-leaf or leaf entry.

When the `MPTE` is valid, the `RESERVED` field must be 0.
If the `VALID` bit is clear, the entry is invalid, and all other bits in the
entry are don't-cares and may be used freely by software.

The `TYPE` field determines the interpretation of the `MPTE`. Unless
specified, the encodings are the same for RV32 and RV64. The `TYPE` field
encoding is as follows:

* 00b - `MPT_NON_LEAF_ENTRY`
* 01b -  XLEN=64: `MPT_NON_LEAF_ENTRY_NAPOT` (see <<Smmpt-napot>>);
         XLEN=32: Reserved
* 10b - `MPT_LEAF_ENTRY`
* 11b - `MPT_LEAF_ENTRY_NAPOT` XLEN=64 NAPOT factor of x32 (see <<Smmpt-napot>>)
         XLEN=32 NAPOT factor of x128 (see <<Smmpt-napot>>)

If the `MPTE.TYPE` specifies a `MPT_NON_LEAF_ENTRY`, the `MPTE` specifies the
next level of the MPT via the `MPTE.PPN` field. For XLEN=64, the non-leaf entry
may specify a NAPOT encoding `MPT_NON_LEAF_ENTRY_NAPOT` to enable optimizing
`MPT` lookup and caching of `MPT` by coalescing entries. (See <<Smmpt-napot>>).

If the `MPTE.TYPE` specifies an `MPT_LEAF_ENTRY`, the `MPTE` specifies the
RWX access permissions for a 4 KiB page. The leaf entry may specify a NAPOT
encoding via `TYPE`=`MPT_LEAF_ENTRY_NAPOT` to specify 2MiB or 1 GiB page
regions for XLEN=64, or 4 MiB pages for XLEN=32 (See <<Smmpt-napot>>)

For `MPTE.TYPE` = `MPT_NON_LEAF_ENTRY` the `PERMS` is specified as a 3b tuple
of Read, Write and Execute permissions as follows:

The `MPTE.PERMS` for the `MPT_NON_LEAF_ENTRY` holds XLEN/4 number of 3-bit
access permissions for a 4 KiB page starting from bit 0 of the field. For
XLEN=64 4 remaining most significant bits are reserved for future use). The
entry is selected by page.pn[1], and the 3-bit field in the entry is selected
using page.pn[0]. See <<rv64-spa>> for XLEN = 64 and <<rv32-spa>> for XLEN = 32.
Thus, there are 3 RWX `PERMS` bits for each 4 KiB page.

[[Smmpt-rw-l1-encoding]]
.`MPTL1` Entry permission encoding
[width="100%",cols="25%,75%",options="header",]
|===
|*`MPTL1` Access-permission encoding* |*Description*
|RWX = 000b a|
The entry specifies access to the 4 KiB address space is *not allowed* for the
domain.
|RWX = 001b a|
The entry specifies *execute-only* access to the 4 KiB address space is
*allowed* for the domain.
|RWX = 010b a|
Reserved - this is an invalid encoding.
|RWX = 011b a|
Reserved - this is an invalid encoding.
|RWX = 100b a|
The entry specifies *read-only* (but *no write* and *no execute*) access is
allowed to the 4 KiB address space for the domain.
|RWX = 101b a|
The entry specifies *read* and *execute* (but *no write*) access is allowed
to the 4 KiB address space for the domain.
|RWX = 110b a|
The entry specifies *read*, *write* (but *no execute*) access is allowed to the
4 KiB address space for the domain.
|RWX = 111b a|
The entry specifies *read*, *write* and *execute* access is allowed to the
4 KiB address space for the domain.
|===

=== MPT access permissions lookup process

MPT access-permissions for a physical address PA in the context of a
supervisor domain are ascertained as follows:

1. Let _a_ be `mmpt.ppn` x PAGESIZE, and let _i_ = LEVELS, based on `MMPT.MODE`;
For XLEN=32 mode `2_level`, LEVELS = 2 and for XLEN=64, LEVELS = 3/4/5 for modes
`3_level`, `4-level`, and `5-level` resp.; PAGESIZE is 2^12^; MPT_PTE_SIZE = 8
bytes for XLEN=64, and MPT_PTE_SIZE = 4 bytes for XLEN=32. The `mmpt`
register must be active, i.e., the effective privilege mode must not be M-mode.

2. If _pa_ is greater than maximum-addressable physical address under the
current MPT mode, or is greater than a platform-defined maximum-addressable
physical address for the hart, then stop and raise an access-fault exception
corresponding to the original access type.

3. Let _mpte_ be the value of the `MPTE` at address _a_ + _pa.pn[i]_
 x MPT_PTE_SIZE. If accessing _mpte_ violates a PMA or PMP check, raise
an access-fault exception corresponding to the original access type.

4. If any bits or encodings that are reserved for future standard use are
set within _mpte_, or _mpte_ is a not-valid `MPTE`, stop and raise an
access-fault exception corresponding to the original access type.

5. Otherwise, the _mpte_ is valid. If _mpte.type_ is `MPTE_LEAF_ENTRY_*` go to
step 6; Otherwise, the _mpte_ is a pointer to the next level of the `MPT`.
Let _i_ = _i_-1. Let _a_ = _mpte.ppn_ x PAGESIZE and go to step 3.
Note that when _mpte.type_ = `MPTE_LEAF_ENTRY`, the _mpte.ppn_ contains the
48b value (XLEN=64) or 24b value (XLEN=32) of the _mpte.perms_ field.

6. A leaf _mpte_ has been found. If any bits or encodings within _mpte.type_
and _mpte.perms_ that are reserved for future standard use, per <<rv64-mpte>>
or <<rv32-mpte>>, are set within _mpte_, stop and raise an access-fault
exception corresponding to the access type.

7. The _mpte_ is a valid leaf _mpte_. Fetch the access-permissions for the
physical address per the steps described below:

* if _i_=2 and _mpte.type_ field is a `MPTE_LEAF_ENTRY_NAPOT`, for XLEN=64,
_mpte_ specifies the access-permissions for 1 GiB page regions (via 32 `MPT` L2
entries with  identical _mpte.perms_ values - see <<Smmpt-napot>>);
go to step 8, else

* if _i_=1, and _mpte.type_ field is a `MPTE_LEAF_ENTRY_NAPOT` value:
For XLEN=64, it specifies the access-permissions for 2 MiB
page region (via 32 `MPT` L1 entries with identical _mpte.perms_ valus - See
<<Smmpt-napot>>;
For XLEN=32, _mpte_ specifies access-permissions for 4 MiB via 128 `MPT` L1
entries with identical _mpte.perms_ values - See <<Smmpt-napot>>.
go to step 8, else

* if _i_=1, the _mpte_ contains XLEN/4 3-bit entries that hold access-permission
encodings for 4 KiB pages. The entry is selected by _pa.pn[0]_. The LSB
3*XLEN/4-1:0 bits holds 3-bit encodings within the entry to specify the
access-permission encoding for the _pa_. The MSB bits of the PPN field are
reserved (4b for XLEN=64). The valid permission encodings are specified in
<<Smmpt-rw-l1-encoding>>.

8. Determine if the requested physical memory access is allowed per the
access-permissions. If access is not permitted, stop and raise an access-fault
exception corresponding to the original access type.

9. The access is allowed per the `MPT` lookup.

All implicit accesses to the `MPT` data structures in
this algorithm are performed using width MPT_PTE_SIZE.

[NOTE]
====
Restricting the _pa_ (in step 2) to the maximum-addressable PA width supported
by a platform allows for optimizing memory requirements of the MPT structures
such as the MPT non-leaf entry tables, when the PA width is not 34, 43, 52 or
64 bits.
====

[NOTE]
====
MPT access-permissions can only further restrict access, and never grant
read, write or execute permission denied by 1st-stage or G-stage translations.
====

=== Smmpt Napot

For XLEN=64, the following `MPTE` encodings are defined when `MPTE.TYPE` is
`MPTE_NON_LEAF_NAPOT`

[[Smmpt-napot]]
.Non-leaf NAPOT `MPTE` encoding
[width="100%",cols="10%,30%,30%,30%",options="header",]
|===
|*i*    a| *PPN[i]*         a| *Description*             a|*Non-leaf PTE napot bits*
|3 or 4 a| x xxx1 0000 0000 a| 2 MiB contiguous L2 or L3 a| 9
|3 or 4 a| x xxx0 xxxx xxxx a| Reserved                  a| -
|5      a| x 1000 0000 0000 a| 16 MiB contiguous L4      a| 12
|5      a| x 0xxx xxxx xxxx a| Reserved                  a| -
|===

NAPOT PTEs behave identical to non-NAPOT PTEs within the MPT lookup algorithm in
<<MPT-lookup>> except that if the encoding in `MPTE` is valid according to table
<<Smmpt-napot>>, then the MPT lookup considers the napot bits to lookup the next
level of the MPT lookup thereby allowing larger next level tables.
If the encoding in pte is reserved according to <<Smmpt-napot>>, then an access-
fault exception must be raised.

[NOTE]
====
The motivation for a NAPOT Leaf and Non-leaf PTE is that it can be cached in a
lookup cache as one or more entries representing the contiguous region as if it
were a single (large) page covered by a single MPT mapping. This compaction can
help relieve MPT cache pressure in some scenarios.

Other non-leaf NAPOT sizes may be defined in the future.
====

For XLEN=64, leaf NAPOT encodings allow 32 L2 or L1 entries to be combined to
specify 1 GiB or 2 MiB page regions.

For XLEN=32, leaf NAPOT encodings allow 128 L1 entries to be combined to specify
4 MiB page regions.

[NOTE]
====
These leaf NAPOT sizes are specified to compose with Sv page sizes. Other leaf
NAPOT sizes may be defined in the future.
====


=== Access Enforcement and Fault Reporting

As shown in <<mpt-lookup>>, and described in the MPT lookup process,
MPT lookup composes with, but does not require,
page-based virtual memory (MMU, IOMMU) and physical memory protection mechanisms
(PMP, Smepmp, IOPMP). When paging is enabled, instructions that access virtual
memory may result in multiple physical-memory accesses, including (implicit
S-mode) accesses to the page tables. MPT checks also apply to these implicit
S-mode accesses - those accesses will be treated as reads for translation and as
writes when A/D bits are updated in page table entries when `Svadu` is
implemented.

MPT is checked for all accesses to physical memory, unless the effective privilege
mode is M, including accesses that have undergone virtual to physical memory
translation, but excluding implicit MPT checker accesses to MPT structures. Data accesses
in M-mode when the MPRV bit in mstatus is set and the MPP field in mstatus contains S
or U are subject to MPT checks. MPT checker accesses to MPT structures are to be
treated as implicit M-mode accesses and are subject to PMP/Smepmp and
IOPMP checks. Implicit accesses to the MPT are governed by `mstatus.MBE` control
for RV64 and `mstatush.MBE` control for RV32. The MPT checker indexes the MPT using the
physical address of the access to lookup and enforce the access permissions.
A mismatch of the access type and the access permissions specified in the
MPT entry that applies to the accessed region is reported as a trap to the
RDSM which may report it to a supervisor domain. To enable composing
with Sv modes, the MPT supports configuration at supported architectural
page sizes. MPT violations manifest as instruction, load, or store access-fault
exceptions. The exception conditions for MPT are checked when the access
to memory is performed.

=== Caching of MPT and Supervisor Domain Fence Instruction

<<mfence-spa>> describes the canonical behavior of the `MFENCE.SPA` instruction
to invalidate cached access-permissions for all supervisor domains, a specific
supervisor domain, or a specific physical address for a supervisor domain.

<<minval-spa>> implemented with `Sinval` describes a finer granular invalidation
of access-permission caches.

When `Smmpt` is implemented, an `MPT` structure is used to specify
access-permissions for physical memory for a supervisor domain, the `MPT`
settings for the resulting physical address (after any address translation) may
be checked (and possibly cached) at any point between the address translation
and the explicit memory access. Therefore, when the `MPT` settings
are modified, `M-mode` software must synchronize the cached `MPT` state with the
virtual memory system and any `PMP`, `MPT` or address-translation caches, as
described via <<mfence-spa>> or in a batched manner via <<minval-spa>>.

When used with the `MPT`, the `MFENCE.SPA` is used to synchronize updates to
in-memory MPT structures with current execution. `MFENCE.SPA` in this case,
applies only to the `MPT` data structures controlled by the
CSR `mmpt`. Executing a `MFENCE.SPA` guarantees that any previous stores already
visible to the current hart are ordered before all implicit reads by that hart
done for the `MPT` for non- `M-mode` instructions that follow the `MFENCE.SPA`.

When `MINVAL.SPA` is used, access-permission cache synchronization may be
batch optimized via the use of the sequence `SFENCE.W.INVAL`, `MINVAL.SPA` and
`SFENCE.INVAL.IR`.

[NOTE]
====
MPT lookups that began while `mmpt` was active are not required to complete or
terminate when `mmpt` is no longer active, unless a `MFENCE.SPA` instruction
matches the `SDID` (and optionally, `PADDR`) is executed. The `MFENCE.SPA`
instruction must be used to ensure that updates to the `MPT` data structures are
observed by subsequent implicit reads to those structures by a hart.
====

If `mmpt.MODE` is changed for a given SDID, a `MFENCE.SPA` with rs1=x0 and rs2
set either to x0 or the given SDID, must be executed to order subsequent PA
access checks with the `MODE` change, even if the old or new `MODE` is `Bare`.
